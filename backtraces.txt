[{ fn: "std::backtrace::Backtrace::create" 
 { fn: "zenoh_transport::unicast::manager::TransportManagerStateUnicast::transports::{{closure}}::{{closure}}" 
 { fn: "<tracing::instrument::Instrumented<T> as core::future::future::Future>::poll" 
 { fn: "zenoh_transport::unicast::manager::TransportManagerStateUnicast::transports::{{closure}}" 
 { fn: "zenoh_transport::unicast::manager::<impl zenoh_transport::manager::TransportManager>::get_transports_unicast::{{closure}}" 
 { fn: "<tracing::instrument::Instrumented<T> as core::future::future::Future>::poll" 
 { fn: "<tracing::instrument::Instrumented<T> as core::future::future::Future>::poll" 
 { fn: "tokio::runtime::park::CachedParkThread<_>::block_on::{{closure}}" 
 { fn: "tokio::runtime::park::CachedParkThread<_>::block_on" 
 { fn: "tokio::runtime::context::blocking::BlockingRegionGuard::block_on" 
 { fn: "tokio::runtime::handle::Handle::block_on_inner::{{closure}}" 
 { fn: "tokio::runtime::context::runtime::enter_runtime" 
 { fn: "tokio::runtime::handle::Handle::block_on_inner" 
 { fn: "tokio::runtime::handle::Handle::block_on" 
 { fn: "zenoh_runtime::ZRuntime::block_in_place::{{closure}}" 
 { fn: "tokio::runtime::context::runtime_mt::exit_runtime" 
 { fn: "tokio::runtime::scheduler::multi_thread::worker::block_in_place" 
 { fn: "tokio::runtime::scheduler::block_in_place::block_in_place" 
 { fn: "tokio::task::blocking::block_in_place" 
 { fn: "zenoh_runtime::ZRuntime::block_in_place" 
 { fn: "<zenoh::net::runtime::RuntimeState as zenoh::net::runtime::IRuntime>::get_transports" 
 { fn: "zenoh::api::admin::init::{{closure}}" 
 { fn: "<F as zenoh::api::handlers::callback::CallbackImpl<T>>::call" 
 { fn: "zenoh::api::handlers::callback::Callback<T>::call" 
 { fn: "zenoh::api::session::SessionInner::broadcast_link_event" 
 { fn: "<zenoh::api::connectivity::ConnectivityPeerHandler as zenoh_transport::TransportPeerEventHandler>::new_link" 
 { fn: "<zenoh::net::runtime::RuntimeSession as zenoh_transport::TransportPeerEventHandler>::new_link" 
 { fn: "zenoh_transport::unicast::manager::<impl zenoh_transport::manager::TransportManager>::notify_new_link_unicast" 
 { fn: "zenoh_transport::unicast::manager::<impl zenoh_transport::manager::TransportManager>::init_new_transport_unicast::{{closure}}" 
 { fn: "zenoh_transport::unicast::manager::<impl zenoh_transport::manager::TransportManager>::init_transport_unicast::{{closure}}" 
 { fn: "zenoh_transport::unicast::establishment::open::open_link::{{closure}}" 
 { fn: "zenoh_transport::unicast::manager::<impl zenoh_transport::manager::TransportManager>::open_transport_unicast::{{closure}}::{{closure}}" 
 { fn: "<tokio::time::timeout::Timeout<T> as core::future::future::Future>::poll" 
 { fn: "zenoh_transport::unicast::manager::<impl zenoh_transport::manager::TransportManager>::open_transport_unicast::{{closure}}" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::connect::{{closure}}" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::connect_peer::{{closure}}" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::autoconnect_all::{{closure}}::{{closure}}::{{closure}}" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::scout::{{closure}}::{{closure}}::{{closure}}" 
 { fn: "<core::pin::Pin<P> as core::future::future::Future>::poll" 
 { fn: "futures_util::future::future::FutureExt::poll_unpin" 
 { fn: "<futures_util::future::select_all::SelectAll<Fut> as core::future::future::Future>::poll::{{closure}}" 
 { fn: "core::iter::traits::iterator::Iterator::find_map::check::{{closure}}" 
 { fn: "<core::iter::adapters::enumerate::Enumerate<I> as core::iter::traits::iterator::Iterator>::try_fold::enumerate::{{closure}}" 
 { fn: "core::iter::traits::iterator::Iterator::try_fold" 
 { fn: "<core::iter::adapters::enumerate::Enumerate<I> as core::iter::traits::iterator::Iterator>::try_fold" 
 { fn: "core::iter::traits::iterator::Iterator::find_map" 
 { fn: "<futures_util::future::select_all::SelectAll<Fut> as core::future::future::Future>::poll" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::scout::{{closure}}::{{closure}}" 
 { fn: "<core::future::poll_fn::PollFn<F> as core::future::future::Future>::poll" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::scout::{{closure}}" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::autoconnect_all::{{closure}}" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::start_scout::{{closure}}::{{closure}}::{{closure}}" 
 { fn: "<core::future::poll_fn::PollFn<F> as core::future::future::Future>::poll" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::start_scout::{{closure}}::{{closure}}" 
 { fn: "<tracing::instrument::Instrumented<T> as core::future::future::Future>::poll" 
 { fn: "zenoh_task::TaskController::spawn_abortable_with_rt::{{closure}}::{{closure}}" 
 { fn: "<core::future::poll_fn::PollFn<F> as core::future::future::Future>::poll" 
 { fn: "zenoh_task::TaskController::spawn_abortable_with_rt::{{closure}}" 
 { fn: "<tokio_util::task::task_tracker::TrackedFuture<F> as core::future::future::Future>::poll" 
 { fn: "<core::pin::Pin<P> as core::future::future::Future>::poll" 
 { fn: "<tracing::instrument::Instrumented<T> as core::future::future::Future>::poll" 
 { fn: "tokio::runtime::task::core::Core<T,S>::poll::{{closure}}" 
 { fn: "tokio::runtime::task::core::Core<T,S>::poll" 
 { fn: "tokio::runtime::task::harness::poll_future::{{closure}}" 
 { fn: "<core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once" 
 { fn: "std::panicking::catch_unwind::do_call" 
 { fn: "___rust_try" 
 { fn: "std::panic::catch_unwind" 
 { fn: "tokio::runtime::task::harness::poll_future" 
 { fn: "tokio::runtime::task::harness::Harness<T,S>::poll_inner" 
 { fn: "tokio::runtime::task::harness::Harness<T,S>::poll" 
 { fn: "tokio::runtime::task::raw::poll" 
 { fn: "tokio::runtime::task::raw::RawTask::poll" 
 { fn: "tokio::runtime::task::LocalNotified<S>::run" 
 { fn: "tokio::runtime::scheduler::multi_thread::worker::Context::run_task::{{closure}}" 
 { fn: "tokio::runtime::scheduler::multi_thread::worker::Context::run_task" 
 { fn: "tokio::runtime::scheduler::multi_thread::worker::Context::run" 
 { fn: "tokio::runtime::scheduler::multi_thread::worker::run::{{closure}}::{{closure}}" 
 { fn: "tokio::runtime::context::scoped::Scoped<T>::set" 
 { fn: "tokio::runtime::context::set_scheduler::{{closure}}" 
 { fn: "std::thread::local::LocalKey<T>::try_with" 
 { fn: "std::thread::local::LocalKey<T>::with" 
 { fn: "tokio::runtime::context::set_scheduler" 
 { fn: "tokio::runtime::scheduler::multi_thread::worker::run::{{closure}}" 
 { fn: "tokio::runtime::context::runtime::enter_runtime" 
 { fn: "tokio::runtime::scheduler::multi_thread::worker::run" 
 { fn: "tokio::runtime::scheduler::multi_thread::worker::block_in_place::{{closure}}::{{closure}}" 
 { fn: "<tokio::runtime::blocking::task::BlockingTask<T> as core::future::future::Future>::poll" 
 { fn: "<tracing::instrument::Instrumented<T> as core::future::future::Future>::poll" 
 { fn: "tokio::runtime::task::core::Core<T,S>::poll::{{closure}}" 
 { fn: "tokio::runtime::task::core::Core<T,S>::poll" 
 { fn: "tokio::runtime::task::harness::poll_future::{{closure}}" 
 { fn: "<core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once" 
 { fn: "std::panicking::catch_unwind::do_call" 
 { fn: "___rust_try" 
 { fn: "std::panic::catch_unwind" 
 { fn: "tokio::runtime::task::harness::poll_future" 
 { fn: "tokio::runtime::task::harness::Harness<T,S>::poll_inner" 
 { fn: "tokio::runtime::task::harness::Harness<T,S>::poll" 
 { fn: "tokio::runtime::task::raw::poll" 
 { fn: "tokio::runtime::task::raw::RawTask::poll" 
 { fn: "tokio::runtime::task::UnownedTask<S>::run" 
 { fn: "tokio::runtime::blocking::pool::Task::run" 
 { fn: "tokio::runtime::blocking::pool::Inner::run" 
 { fn: "tokio::runtime::blocking::pool::Spawner::spawn_thread::{{closure}}" 
 { fn: "std::sys::backtrace::__rust_begin_short_backtrace" 
 { fn: "std::thread::Builder::spawn_unchecked_::{{closure}}::{{closure}}" 
 { fn: "<core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once" 
 { fn: "std::panicking::catch_unwind::do_call" 
 { fn: "___rust_try" 
 { fn: "std::thread::Builder::spawn_unchecked_::{{closure}}" 
 { fn: "core::ops::function::FnOnce::call_once{{vtable.shim}}" 
 { fn: "std::sys::thread::unix::Thread::new::thread_start" 
 { fn: "__pthread_cond_wait" }]

[{ fn: "std::backtrace::Backtrace::create" 
 { fn: "zenoh_transport::unicast::manager::TransportManagerStateUnicast::transports::{{closure}}::{{closure}}" 
 { fn: "<tracing::instrument::Instrumented<T> as core::future::future::Future>::poll" 
 { fn: "zenoh_transport::unicast::manager::TransportManagerStateUnicast::transports::{{closure}}" 
 { fn: "zenoh_transport::unicast::manager::<impl zenoh_transport::manager::TransportManager>::get_transport_unicast::{{closure}}" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::connect::{{closure}}" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::connect_peer::{{closure}}" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::autoconnect_all::{{closure}}::{{closure}}::{{closure}}" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::scout::{{closure}}::{{closure}}::{{closure}}" 
 { fn: "<core::pin::Pin<P> as core::future::future::Future>::poll" 
 { fn: "futures_util::future::future::FutureExt::poll_unpin" 
 { fn: "<futures_util::future::select_all::SelectAll<Fut> as core::future::future::Future>::poll::{{closure}}" 
 { fn: "core::iter::traits::iterator::Iterator::find_map::check::{{closure}}" 
 { fn: "<core::iter::adapters::enumerate::Enumerate<I> as core::iter::traits::iterator::Iterator>::try_fold::enumerate::{{closure}}" 
 { fn: "core::iter::traits::iterator::Iterator::try_fold" 
 { fn: "<core::iter::adapters::enumerate::Enumerate<I> as core::iter::traits::iterator::Iterator>::try_fold" 
 { fn: "core::iter::traits::iterator::Iterator::find_map" 
 { fn: "<futures_util::future::select_all::SelectAll<Fut> as core::future::future::Future>::poll" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::scout::{{closure}}::{{closure}}" 
 { fn: "<core::future::poll_fn::PollFn<F> as core::future::future::Future>::poll" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::scout::{{closure}}" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::autoconnect_all::{{closure}}" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::start_scout::{{closure}}::{{closure}}::{{closure}}" 
 { fn: "<core::future::poll_fn::PollFn<F> as core::future::future::Future>::poll" 
 { fn: "zenoh::net::runtime::orchestrator::<impl zenoh::net::runtime::Runtime>::start_scout::{{closure}}::{{closure}}" 
 { fn: "<tracing::instrument::Instrumented<T> as core::future::future::Future>::poll" 
 { fn: "zenoh_task::TaskController::spawn_abortable_with_rt::{{closure}}::{{closure}}" 
 { fn: "<core::future::poll_fn::PollFn<F> as core::future::future::Future>::poll" 
 { fn: "zenoh_task::TaskController::spawn_abortable_with_rt::{{closure}}" 
 { fn: "<tokio_util::task::task_tracker::TrackedFuture<F> as core::future::future::Future>::poll" 
 { fn: "<core::pin::Pin<P> as core::future::future::Future>::poll" 
 { fn: "<tracing::instrument::Instrumented<T> as core::future::future::Future>::poll" 
 { fn: "tokio::runtime::task::core::Core<T,S>::poll::{{closure}}" 
 { fn: "tokio::runtime::task::core::Core<T,S>::poll" 
 { fn: "tokio::runtime::task::harness::poll_future::{{closure}}" 
 { fn: "<core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once" 
 { fn: "std::panicking::catch_unwind::do_call" 
 { fn: "___rust_try" 
 { fn: "std::panic::catch_unwind" 
 { fn: "tokio::runtime::task::harness::poll_future" 
 { fn: "tokio::runtime::task::harness::Harness<T,S>::poll_inner" 
 { fn: "tokio::runtime::task::harness::Harness<T,S>::poll" 
 { fn: "tokio::runtime::task::raw::poll" 
 { fn: "tokio::runtime::task::raw::RawTask::poll" 
 { fn: "tokio::runtime::task::LocalNotified<S>::run" 
 { fn: "tokio::runtime::scheduler::multi_thread::worker::Context::run_task::{{closure}}" 
 { fn: "tokio::runtime::scheduler::multi_thread::worker::Context::run_task" 
 { fn: "tokio::runtime::scheduler::multi_thread::worker::Context::run" 
 { fn: "tokio::runtime::scheduler::multi_thread::worker::run::{{closure}}::{{closure}}" 
 { fn: "tokio::runtime::context::scoped::Scoped<T>::set" 
 { fn: "tokio::runtime::context::set_scheduler::{{closure}}" 
 { fn: "std::thread::local::LocalKey<T>::try_with" 
 { fn: "std::thread::local::LocalKey<T>::with" 
 { fn: "tokio::runtime::context::set_scheduler" 
 { fn: "tokio::runtime::scheduler::multi_thread::worker::run::{{closure}}" 
 { fn: "tokio::runtime::context::runtime::enter_runtime" 
 { fn: "tokio::runtime::scheduler::multi_thread::worker::run" 
 { fn: "tokio::runtime::scheduler::multi_thread::worker::block_in_place::{{closure}}::{{closure}}" 
 { fn: "<tokio::runtime::blocking::task::BlockingTask<T> as core::future::future::Future>::poll" 
 { fn: "<tracing::instrument::Instrumented<T> as core::future::future::Future>::poll" 
 { fn: "tokio::runtime::task::core::Core<T,S>::poll::{{closure}}" 
 { fn: "tokio::runtime::task::core::Core<T,S>::poll" 
 { fn: "tokio::runtime::task::harness::poll_future::{{closure}}" 
 { fn: "<core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once" 
 { fn: "std::panicking::catch_unwind::do_call" 
 { fn: "___rust_try" 
 { fn: "std::panic::catch_unwind" 
 { fn: "tokio::runtime::task::harness::poll_future" 
 { fn: "tokio::runtime::task::harness::Harness<T,S>::poll_inner" 
 { fn: "tokio::runtime::task::harness::Harness<T,S>::poll" 
 { fn: "tokio::runtime::task::raw::poll" 
 { fn: "tokio::runtime::task::raw::RawTask::poll" 
 { fn: "tokio::runtime::task::UnownedTask<S>::run" 
 { fn: "tokio::runtime::blocking::pool::Task::run" 
 { fn: "tokio::runtime::blocking::pool::Inner::run" 
 { fn: "tokio::runtime::blocking::pool::Spawner::spawn_thread::{{closure}}" 
 { fn: "std::sys::backtrace::__rust_begin_short_backtrace" 
 { fn: "std::thread::Builder::spawn_unchecked_::{{closure}}::{{closure}}" 
 { fn: "<core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once" 
 { fn: "std::panicking::catch_unwind::do_call" 
 { fn: "___rust_try" 
 { fn: "std::thread::Builder::spawn_unchecked_::{{closure}}" 
 { fn: "core::ops::function::FnOnce::call_once{{vtable.shim}}" 
 { fn: "std::sys::thread::unix::Thread::new::thread_start" 
 { fn: "__pthread_cond_wait" }]
